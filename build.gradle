buildscript {
    repositories { mavenCentral() }
    dependencies {
        classpath 'gradle.plugin.com.github.johnrengelman:shadow:7.1.2'
    }
}

plugins {
    id 'io.franzbecker.gradle-lombok' version '5.0.0' apply false
    id 'pl.allegro.tech.build.axion-release' version '1.13.14'
    id "com.jfrog.artifactory" version "4.31.4" apply false
    id 'jacoco'
    id 'com.chrisgahlert.gradle-dcompose-plugin' version '0.17.2' apply false
}

wrapper {
    gradleVersion = '8.0.1'
    distributionUrl = "https://services.gradle.org/distributions/gradle-$gradleVersion-all.zip"
}

private Map getHostInfo() {
    def info = [:]
    try {
        info.name = InetAddress.localHost.hostName
        info.ip = InetAddress.localHost.hostAddress
    } catch (Exception e) {
        info.name = 'localhost'
        info.ip = '127.0.0.1'
    }
    return info
}

group 'io.vantiq'
// version scmVersion.version

// scmVersion {
//    versionIncrementer 'incrementMinor'
// }

ext {
}


// Add idea support in root project to get around bug in Scala plugin
apply plugin: 'idea'

allprojects {
    group 'io.vantiq'
    //version scmVersion.version

    // apply from: project(':').file('gradle/publish.gradle')

    configurations.all {
        resolutionStrategy {
            // cache dynamic versions for 10 minutes
            cacheDynamicVersionsFor 10 * 60, 'seconds'
            // don't cache changing modules at all
            cacheChangingModulesFor 0, 'seconds'
        }
    }
}

// Here, at config time, we'll set these properties to empty values.  This allows the dcompose-generated
// tasks to complete without throwing errors. Any publish operations may fail, but they would fail anyway
// since no credentials were provided.  If these aren't set, creating the images (which will be saved in the
// local docker) will fail without a good reason. Setting these values allows the buildImages tasks to
// complete without incident.

if (!rootProject.hasProperty('dockerRegistryUser')) {
    project.ext.setProperty('dockerRegistryUser', '')
    logger.warn('The property "dockerRegistryUser" was not provided. This may affect publish operations.')
}
if (!rootProject.hasProperty('dockerRegistryPassword')) {
    project.ext.setProperty('dockerRegistryPassword', '')
    logger.warn('The property "dockerRegistryPassword" was not provided. This may affect publish operations.')
}

def pythonProjects = ['pythonsdk'] as Set<String>

subprojects {
    // Don't configure the python projects
    if (pythonProjects.contains(it.name)) {
        return
    }
    println("configuring project ${it.name}")
    apply plugin: 'groovy'
    apply plugin: 'idea'
    apply plugin: 'eclipse'
    apply plugin: 'java'
    apply plugin: 'com.chrisgahlert.gradle-dcompose-plugin'

    // Using gradle-dcompose-plugin to build/push docker images
    dcompose {
        if (rootProject.hasProperty('dockerRegistry') && rootProject.hasProperty('pathToRepo')) {
            def registryName = rootProject.getProperty('dockerRegistry')
            def pathToRepo = rootProject.getProperty('pathToRepo')
            def repositoryName = "${project.name - 'Source' + '-source'}".toLowerCase()
            if (rootProject.hasProperty('repositoryName')) {
                repositoryName = rootProject.getProperty('repositoryName')
            }

            connector {
                buildFiles = project.copySpec {
                    from "$projectDir/src/main/docker/"
                    from "$projectDir/build/distributions/${project.name}.tar"
                    if (rootProject.hasProperty('connectorSpecificInclusions')) {
                        def inclusionsDir = rootProject.getProperty('connectorSpecificInclusions')
                        from "$inclusionsDir"
                    }
                }

                def repositoryBase = registryName + '/' + pathToRepo + '/' + repositoryName
                repositoryBase = repositoryBase.replace('//', '/')
                repository = rootProject.hasProperty('imageTag') ? repositoryBase + ":${rootProject.getProperty('imageTag')}" : repositoryBase
                logBuildStatus = true
                buildLogFile = file("$buildDir/dockerBuildLog.txt")
            }

            // The credentials here should be stored in gradle.properties.
            registry(registryName) {
                withUsername dockerRegistryUser
                withPassword dockerRegistryPassword
            }
        }
    }
    
// Not sure if service connectors will have this
//    if (project.tasks.findByName('buildConnectorImage')) {
//        buildConnectorImage.dependsOn assemble
//    }

    // only run with code-coverage metrics if property is explicitly specified
    if (rootProject.hasProperty('jacocoReport')) {
        apply plugin: "jacoco"
    }

    sourceCompatibility = 1.8
    java.sourceCompatibility = 1.8
    java.targetCompatibility = JavaVersion.VERSION_1_8
    
    // Simulate provided dependencies
    configurations {
        provided
    }

    //Include provided for compilation
    sourceSets.main.compileClasspath += configurations.provided
    sourceSets.test.compileClasspath += configurations.provided
    sourceSets.test.runtimeClasspath += configurations.provided

    idea {
        module {
            scopes.PROVIDED.plus += [configurations.provided]
        }
    }

    eclipse {
        classpath {
            plusConfigurations += [configurations.provided]
        }
    }

    repositories {
        mavenCentral()
        maven { url 'https://jitpack.io' }
    }

    dependencies {
    }

    compileGroovy {
        groovyOptions.javaAnnotationProcessing = true
    }

    // Generate dependency report for all subprojects
    task allDeps(type: DependencyReportTask) {}

    test {
        useJUnit {
        }

        // We are a UTF-8 system
        jvmArgs '-Dfile.encoding=UTF-8'

        // Print out test names as they run
        if (rootProject.hasProperty('showTests')) {
            beforeTest { descriptor ->
                logger.lifecycle("$descriptor")
            }
        }

        // show standard out and standard error of the test JVM(s) on the console
        if (rootProject.hasProperty('showTestOutput')) {
            testLogging.showStandardStreams = true
        }

        testLogging {
            // have info about failures output to console...
            exceptionFormat = 'full'

            // print test totals to console at end of tests
            afterSuite { desc, result ->
                if (!desc.parent) { // will match the outermost suite
                    println "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                }
            }
        }

        def jenkinsHome = System.env.JENKINS_HOME

        if (jenkinsHome != null && jenkinsHome.length() > 0) {
            // continue the build on test failures, so that all tests get run & we get one total...
            // AND in jenkins, the build is continued with later reports collected...
            ignoreFailures = true
        }
    }
}

apply plugin: 'java'

repositories {
    mavenCentral()
    maven { url 'https://jitpack.io' }
}


// include base plugin so 'clean' will delete the top-level build directory,
// and thus clean old jacoco and testReport results
apply plugin: 'base'

// This task will create an aggregate report on test results for all subprojects...
//     ./gradlew testReport --continue
// BUT this only seems to work during a test run if there were 0 failures!
// If there are failures, can generate the combined report without running tests again
// by using -xtest:
//     ./gradlew testReport -xtest
// Otherwise, this task will RUN ALL the tests, rather than just collecting the existing reports...
//     
task testReport(type: TestReport) {
    destinationDir = file("$buildDir/reports/allTests")
    // Include the results from the `test` task in all subprojects
    subprojects.each { subproject ->
        subproject.tasks.withType(Test).each { testTask ->
            println testTask
            reportOn testTask
        }
    }
//    reportOn subprojects*.test
}

def publishedProjects = subprojects.findAll { !pythonProjects.contains(it.name) }

// This task will create a combined code-coverage report for the unit tests.
// To generate the data for this report, need to run tests with the jacocoReport flag:
//     ./gradlew -PjacocoReport=true jacocoRootReport --continue
// The combined report goes into:
//     build/reports/jacoco/jacocoRootReport/html/index.html
//     
// If you forgot the --continue flag and have failures during tests, you can generate
// the combined jacoco report without re-running tests, by doing
//     ./gradlew jacocoRootReport -PjacocoReport=true -xtest
// (without the -xtest, it will re-run all the tests...)
//
// Note: To generate a report for JUST ONE SUBPROJECT, you can run 'jacocoTestReport' in
// that one subproject, e.g.
//     cd analytics
//     ../gradlew -PjacocoReport=true test jacocoTestReport  --continue
//         -or-
//     ./gradlew  -PjacocoReport=true :analytics:test :analytics:jacocoTestReport
// The single report goes into each subproject, e.g.:
//     analytics/build/reports/jacoco/test/html/index.html
// 
task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
    description = 'Generates an aggregate report from all subprojects'

    dependsOn(publishedProjects.test)

    additionalSourceDirs.setFrom(files(publishedProjects.sourceSets.main.allSource.srcDirs))
    sourceDirectories.setFrom(files(publishedProjects.sourceSets.main.allSource.srcDirs))
    classDirectories.setFrom(files(publishedProjects.sourceSets.main.output))
    // disable this report unless jacocoReport is specified
    if (rootProject.hasProperty('jacocoReport')) {
        executionData.setFrom(files(publishedProjects.jacocoTestReport.executionData))
    } else {
        executionData.setFrom(files('dummy'))  // just create empty list if property not specified
    }

    doFirst {
        executionData.setFrom(files(executionData.findAll { it.exists() }))
        classDirectories.setFrom(files(classDirectories.findAll {
            // exclude the sqlsvc directory/module, because it contains a duplicate class;
            // i.e.    io/vantiq/service/storage/DatabaseServiceModule.class
            // is in both dbservice/mongodbsvc & dbservice/sqlsvc
            it.exists() && !(it.absolutePath.contains('sqlsvc'))
        }))
    }

    reports {
        html.required.set(true) // human readable
        xml.required.set(true) // human readable
    }
}
